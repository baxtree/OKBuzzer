<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta content="public" name="security" />
<meta content="index,follow" name="Robots" />
<meta content="(PICS-1.1 &quot;http://www.icra.org/ratingsv02.html&quot; l gen true r (cz 1 lz 1 nz 1 oz 1 vz 1) &quot;http://www.rsac.org/ratingsv01.html&quot; l gen true r (n 0 s 0 v 0 l 0) &quot;http://www.classify.org/safesurf/&quot; l gen true r (SS~~000 1))" http-equiv="PICS-Label" />
<meta content="reference" name="DC.Type" />
<meta content="Asynchronous request dispatcher application design considerations" name="DC.Title" />
<meta content="Asynchronous request dispatcher (ARD) is not a one-size-fits-all solution to servlet programming. You must evaluate the needs of your application and the caveats of using ARD. Switching all includes to start asynchronously is not the solution for every scenario, but when used wisely, ARD can increase response time. This article contains important details about the ARD implementation and issues to consider when you design an application that leverages ARD." name="abstract" />
<meta content="Asynchronous request dispatcher (ARD) is not a one-size-fits-all solution to servlet programming. You must evaluate the needs of your application and the caveats of using ARD. Switching all includes to start asynchronously is not the solution for every scenario, but when used wisely, ARD can increase response time. This article contains important details about the ARD implementation and issues to consider when you design an application that leverages ARD." name="description" />
<meta content="tweb_ard.html" name="DC.Relation" scheme="URI" />
<meta content="cweb_ard.html" name="DC.Relation" scheme="URI" />
<meta content="http://www.ibm.com/developerworks/websphere/techjournal/0608_hesmer/0608_hesmer.html" name="DC.Relation" scheme="URI" />
<meta content="IBM Corporation 2008, 2011" name="copyright" />
<meta content="IBM Corporation 2008, 2011" name="DC.Rights.Owner" />
<meta content="XHTML" name="DC.Format" />
<meta content="rwebardconsiderations" name="DC.Identifier" />
<meta content="en-us" name="DC.Language" />
<!-- All rights reserved. Licensed Materials Property of IBM -->
<!-- US Government Users Restricted Rights -->
<!-- Use, duplication or disclosure restricted by -->
<!-- GSA ADP Schedule Contract with IBM Corp. -->
<link href="../../ibmdita.css" rel="stylesheet" type="text/css" />
<link href="../../swg_info_common.css" rel="stylesheet" type="text/css" />
<link disabled="" href="../../monospace.css" rel="stylesheet" type="text/css" />
<title>Asynchronous request dispatcher considerations</title>
<style type="text/css" xml:space="preserve">
        span.stealth { visibility:hidden; }
   </style>
<script language="JavaScript" src="../../../../../scriptsfiles/icscript.js" xml:space="preserve"> 
</script>


<script src="../../../../../advanced/synchWithToc.js" type="text/javascript" xml:space="preserve"> </script>

<link charset="ISO-8859-1" href="../content/PLUGINS_ROOT/org.eclipse.help.webapp/advanced/breadcrumbs.css" rel="stylesheet" type="text/css" />
<script src="../content/PLUGINS_ROOT/org.eclipse.help/livehelp.js" type="text/javascript" xml:space="preserve"> </script>

<script type="text/javascript">if( self == top ){ window.location.replace( "../../../../../index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/rweb_ard_considerations.html");}</script>
<script type="text/javascript">
<!--
if (parent.ContentToolbarFrame && parent.ContentToolbarFrame.setButtonState) parent.ContentToolbarFrame.setButtonState("toggle_highlight","hidden");
-->
</script>

</head>
<body id="rwebardconsiderations" xmlns:xalan="http://xml.apache.org/xslt">
<div class="help_breadcrumbs">
<a href="../../../../../topic/com.ibm.websphere.express.doc/info/exp/ae/welcome_express.html" shape="rect">Express (Distributed operating systems), Version 7.0</a> &gt; <a href="../../../../../topic/com.ibm.websphere.express.doc/info/exp/ae/welc_ref.html" shape="rect">Reference</a> &gt; <a href="../../../../../topic/com.ibm.websphere.express.doc/info/exp/ae/welc_ref_dev_consid.html" shape="rect">Developer best practices</a>
</div>
<a name="rwebardconsiderations" shape="rect">
<!-- -->
</a>
<span class="stealth" style="display:none">File name: rweb_ard_considerations.html</span>
<br clear="none" />
<h1 class="topictitle1">Asynchronous request dispatcher application design considerations</h1>




<div>
<p>Asynchronous request dispatcher (ARD) is not a one-size-fits-all
solution to servlet programming. You must evaluate the needs of your
application and the caveats of using ARD. Switching all includes to
start asynchronously is not the solution for every scenario, but when
used wisely, ARD can increase response time. This article contains
important details about the ARD implementation and issues to consider
when you design an application that leverages ARD.</p>

<div class="section"></div>

<div class="section">
<h4 class="sectiontitle">Asynchronous request dispatcher client-side implementation </h4>
<div class="p">
<ul>
<li>JavaScript is dynamically written to the
response output. </li>

<li>This JavaScript results in Ajax
requests back to a server-side results provider. </li>

<li>Because of the Asynchronous Input/Output (AIO) features of the
channel, the Ajax request does not tie up a thread and instead is
notified for completion through an include callback. </li>

<li>The client only makes one request at a time for the asynchronous
includes because of browser limitations in the number of connections. </li>

<li>Original connection has to be valid for the lifetime of the includes.
It cannot be reused for the Ajax requests.</li>

<li>Comment nodes, such as following,<pre xml:space="preserve">&lt;!--uniquePlaceholderID--&gt;&lt;!--1--&gt;</pre>
 are
placed in the browser object model since comment nodes have no effect
on the page layout. </li>

<li>Whenever a complete fragment exists, a response can be sent to
the client and the comment node with the same ID is replaced. Requests
are made until all the fragments are retrieved. </li>

<li>Verify applications on all supported browsers when using client-side
aggregation. Object oriented JavaScript principles
are used so that applications only need avoid using the method name
getDynamicDataIBMARD. Any previously specified window.onload is started
before the ARD onload method.</li>


</ul>

</div>

</div>

<div class="section">
<h4 class="sectiontitle">Asynchronous request dispatcher channel results service </h4>
<p>Requests
for include data from the asynchronous JavaScript code
are sent to known Uniform Resource Identifiers, URIs also known as
URLs, that the ARD channel can intercept to prevent traveling through
Web container request handling. These URIs are unique for the each
server restart.</p>
<p>For example,<kbd class="userinput"> /IBMARD01234567/asyncInclude.js</kbd> is
the URI for the JavaScript that forces the
retrieval of the results, and <kbd class="userinput">/IBMARD01234567/IBMARDQueryStringEntries?=12000</kbd> is
used to retrieve the results for the entry with ID 12000.</p>
<p>To
prevent unauthorized results access, unique IDs are generated for
the service URI and for the ARD entries. A common ID generator is
shared among the session and ARD, so uniqueness is configurable through
session configuration. Session IDs are considered secure, but they
are not as secure as using a Lightweight Third-Party Authentication
(LTPA) token.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Custom client-side aggregation </h4>
<div class="p">If you want
to perform your own client-side aggregation, the isUseDefaultJavascript
method  must return as false.  The isUseDefaultJavascript method is
part of the AsyncRequestDispatcherConfig method, which is set on the
AsyncRequestDispatcher or for the AsyncRequestDispatcherConfigImpl.getRef
method. The AsyncRequestDispatcherConfigImpl.getRef method is the
global configuration object. You might want to perform your own client-side
aggregation if the back button functionality is problematic. You must
remove the results from the generic results service to prevent memory
leaks, so that multiple requests with the same response results through
an XMLHttpRequest fail. To facilitate proper location of position,
placeholders are still written in the code as<pre xml:space="preserve">&lt;!--uniquePlaceholderID--&gt;&lt;!--x--&gt;</pre>
 where
x is the order of the includes. The endpoint to retrieve results are
retrieved from the request attribute com.ibm.websphere.webcontainer.ard.endpointURI.</div>
<div class="p">When
making a request to the endpoint, ARD sends as many response fragments
as possible when the request is made. Therefore, the client needs
to re-request if all fragments are not initially returned. Trying
to display the results directly in a browser without using an XMLHttpRequest
can result in errors related to non well-formed XML. The response
data is returned in the following format with a content type of text/xml:<pre xml:space="preserve">&lt;div id=&quot;2&quot;&gt;&lt;BR&gt;Servlet 3--dispatcher3 requesting Servlet3 to sleep for 0 seconds at: 1187967704265 
&lt;BR&gt; Servlet 3--Okay, all done!  This should print pop up: third at: 1187967704281 &lt;/div&gt;</pre>

</div>
<p>For
additional information about the AsyncRequestDispatcherConfig and
the AsyncRequestDispatcher interfaces, review the com.ibm.websphere.webcontainer.async
package in the application programming interfaces (API) documentation.
The generated API documentation is available in the information center
table of contents from the path <span class="menucascade">
<span class="uicontrol">Reference</span>
 &gt; <span class="uicontrol">APIs - Application Programming Interfaces</span>
</span>. </p>

</div>

<div class="section">
<h4 class="sectiontitle">Server-side aggregation </h4>
<p>Like client-side
aggregation, server-side aggregation uses the ARD channel as a results
service.   The ARD channel knows which asynchronous includes have
occurred for certain set of buffers. Those buffers can then be searched
for an include placeholder. Because of the issues of JSP buffering,
the placeholder for the include might not be in the searched buffers.
If this occurs, the next set of buffers must also look for any include
placeholders missed in the previous set. ARD attempts to iteratively
aggregate as includes return so that response content can be sent
to the client as soon as possible.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Asynchronous beans </h4>
<p>An AsynchBeans work manager
is used to start the includes. If the number of currently requested
includes is greater than the work manager maximum thread pool size
and this size is not growable, it starts the work on the current thread
and skips the placeholder write. Utilizing AsynchBeans suppports propagation
of the J2EE context of the original thread including work area, internationalization,
application profile, z/OS<sup>®</sup> operation system work load
management, security, transaction, and connection context.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Timer </h4>
<p>A single timer is used for ARD and
timer tasks are created for all the timeout types of ARD requests.
Tasks registered with the timer are not guaranteed to run at the exact
time specified because the timer runs on a single thread, therefore
one timeout might have to wait for the other timeout actions to complete.
The timer is used as a last resort.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Remote request dispatcher </h4>
<p>Optionally, ARD
can be used in concert with the remote request dispatcher. The remote
request dispatcher was introduced in <span>WebSphere<sup>®</sup> Application Server, Network Deployment</span> 6.1. The remote
request dispatcher runs the include on a different application server
in a core group by serializing the request context into a SOAP message
and using Web services to call the remote server. This is useful when
the expense of creating and sending a SOAP message through Web services
is outweighed by issuing the request locally.  For more information,
see the IBM WebSphere Developer Technical Journal: Include remote
files in your Web application seamlessly with the new Remote Request
Dispatcher developerWorks article.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Exceptions </h4>
<p>In the case of an exception in
an included servlet, the Web container goes through the error page
definitions mapped to exception types. So an error page defined in
the deployment descriptor shows up as a portion of the aggregated
page. Insert logic into the error page itself if behavior is different
for an include. Because the include runs asynchronously, there is
no guarantee that the top level servlet is still in service, therefore
the exception is not propagated back from an asynchronous include
like a normal include. Other includes finish so that partial pages
can be displayed.</p>
<p>If the ARD work manager runs out of worker
threads, the include is processed like a synchronous include. This
is the default setting, but the work manager can also grow such that
it does not result in this condition. This change in processing is
invisible to the user during processing but is noted once in the system
logs as a warning message and the rest of the time in the trace logs
when enabled. Other states that can trigger the include to occur synchronously
are reaching the maximum percentage of expired requests over a time
interval and reaching the maximum size of the results store.</p>
<p>There
are cases where exceptions happen outside of the scope of normal error
page handling. For example, work can be rejected by the work manager.
A timer can expire waiting for an include response to return. The
ARD channel, acting as a generic service to retrieve the results,
might receive an ID that is not valid. In these cases, there is no
path to the error page handling because the context is missing, such
as ServletRequest, ServletResponse, and ServletContext, for the request
to work. To mitigate these issues, you can use the AsyncRequestDispatcherConfig
interface to provide custom error messages. Defaults are provided
and internationalized as needed.</p>
<p>Exceptions can also occur outside
the scope of the request the custom configuration was set on, such
as on the subsequent client-side XMLHttpRequests. In this case, the
global configuration must be altered. This can be retrieved through
com.ibm.wsspi.ard.AsyncRequestDispatcherConfigImpl.getRef().</p>
<div class="p">
<dl>

<dt class="dlterm">Include start </dt>

<dd>The work manager provides a timeout for how long to wait for an
include to start. Since this typically happens immediately, there
is not a programmatic way to enable this. However, this is configurable
in the work manager settings. By default, you will not encounter this
because of the maximum thread check before scheduling the work. Work
can be retried if setRetriable(true) is called on the in use AsyncRequestDispatcherConfig.</dd>


<dt class="dlterm">Include finish </dt>

<dd>The initiated timeout starts after the work is accepted. It can
be configured through the console or programmatically through the
AsyncRequestDispatcherConfig.setExecutionTimeoutOverride method; The
default value is 60000 ms, or one minute. In place of the include
results, the message from the AsyncRequestDispatcherConfig.setExecutionTimeoutMessage
is sent. If this intiated timeout is reached, but the actual include
results are ready when the data can be flushed, preference is given
to the actual results. Also, this does not apply to insertFragmentBlocking
calls which always wait until the include is completed.</dd>


<dt class="dlterm">Expiration of results </dt>

<dd>Since the client-side has to hold the results in a service to
send for the Ajax request, we want a way to expire the results if
the client goes down and never retrieves the entry. The default of
a minute is sufficient for a typical request because the Ajax request
would come in immediately after sending the response. The timer can
be configured programmatically via the setExpirationTimeoutOverride
method the of AsyncRequestDispatcherConfig. The message from the getOutputRetrievalFailureMessage
method of AsyncRequestDispatcherConfig is displayed when someone tries
to access an entry that has expired and been removed from cache. This
message is the same message that is sent to someone requesting a result
with an ID that never existed.</dd>


</dl>

</div>

</div>

<div class="section">
<h4 class="sectiontitle">Includes versus fragments </h4>
<p>Consider which
operations can be done asynchronously and when they can start. Ideally,
all the includes are completed when the getFragment calls are made
at the beginning of the request so that the includes can have more
time to complete, and upon inserting the fragments, there would be
less extra buffering and aggregating if they have completed. However,
simply calling an asynchronous include is easier because it follows
the same pattern as a normal request dispatcher include.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Web container </h4>
<div class="p">
<dl>
<dt class="dlterm">ServletContext </dt>

<dd>When doing cross-context includes, the context that is a target
of the include must also have ARD enabled because the Web application
must have been initialized for ARD for its servlet context to have
valid methods to retrieve an AsyncRequestDispatcher. The aggregation
type is determined by the original context's configuration because
you cannot mix aggregation types.</dd>


<dt class="dlterm">ServletRequest </dt>

<dd>You must clone the request for each include. Otherwise, conflicts
between threads might occur. Because applications can wrap the default
request objects, your wrappers must implement the com.ibm.wsspi.webcontainer.servlet.IServletRequest
interface, which has one method, the	public Object clone method, which
creates the CloneNotSupportedException.</dd>

<dd class="ddexpand">Unwrapping occurs until a request wrapper that implements this
interface is found. Non-implementing wrappers are lost; however, a
servlet filter configured for the include can rewrap the response.</dd>

<dd class="ddexpand">Changes made to the ServletRequest are not propagated back to
the top level servlet unless transferState on the AsyncRequestDispatcherConfig
is enabled and insertFragmentBlocking is called.</dd>


<dt class="dlterm">ServletResponse  </dt>

<dd>A wrapped response extending com.ibm.websphere.servlet.response.StoredResponse
is created by ARD and sent to the includes because the response output
must be retrievable beyond the lifecycle of the original response. </dd>

<dd class="ddexpand">Internal headers set in asynchronous includes are not supported
due to lifecycle restrictions unless transferState on the AsyncRequestDispatcher
config is enabled and insertFragmentBlocking is called. Normal headers
are not supported in a synchronous include as specified by the servlet
specification. </dd>

<dd class="ddexpand">Include filters can rewrap the new response and must flush upon
completion.</dd>


<dt class="dlterm">ServletInputStream </dt>

<dd>An application reading parameters using getParameter is not problematic.Parsing
of parameters is forced before the first asynchronous include to prevent
concurrent access to the input stream.</dd>


<dt class="dlterm">HttpSession </dt>

<dd>Initial getSession calls that result in a Set-Cookie header must
be called from the top level servlet because it is unpredictable when
the includes are started and if the headers have already been flushed.
The exception is when transferState on the AsyncRequestDispatcherConfig
is enabled and an insertFragmentBlocking is called. This normally
creates an exception when you add the header.</dd>


<dt class="dlterm">Filters </dt>

<dd>If there is a filter for an include, the filter is issued on the
asynchronous thread.</dd>


<dt class="dlterm">Nested asynchronous includes </dt>

<dd>Nested asynchronous includes are not supported because they complicate
aggregation. However, an asynchronous include can have nested synchronous
includes. Any attempt to perform a nested asynchronous include reverts
back to a synchronous include. </dd>


</dl>

</div>

</div>

<div class="section">
<h4 class="sectiontitle">Transactions </h4>
<p>Every asynchronous bean method
is called using its own transaction, much like container-managed transactions
in typical enterprise beans. The runtime starts a local transaction
before invoking the method. The asynchronous bean method can start
its own global transaction if this transaction is possible for the
calling J2EE component. </p>
<p>If the asynchronous bean method creates
an exception, any local transactions are rolled back. If the method
returns normally, any incomplete local transactions are completed
according to the unresolved action policy configured for the bean.
If the asynchronous bean method starts its own global transaction
and does not commit this global transaction, the transaction is rolled
back when the method returns.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Connection management </h4>
<div class="p">An asynchronous bean
method can use the connections that its creating servlet obtained
using java:comp resource references. However, the bean method must
access those connections using a get, use or close pattern. There
is no connection caching between method calls on an asynchronous bean.
The connection factories or data sources can be cached, but the connections
must be retrieved on every method call, used, and then closed. While
the asynchronous bean method can look up connection factories using
a global Java Naming and Directory Interface
(JNDI) name, this is not recommended for the following reasons:  <ul>
<li>The JNDI name is hard coded in the application, for example, as
a property or string literal. </li>

<li>The connection factories are not shared because there is no way
to specify a sharing scope.</li>


</ul>
 Evaluate high load scenarios because asynchronous includes might
increase the number of threads waiting on the connection.</div>

</div>

<div class="section">
<h4 class="sectiontitle">Performance </h4>
<p>Because includes are completed
asynchronously, the total performance data for a request must take
into consideration the performance of the asynchronous includes. The
total time of the request could previously be understood by the time
for the top level servlet to complete, but now that servlet is exiting
before the includes are completed. The top level servlet still accounts
for much of the additional setup time required for each include.  </p>
<p>Therefore,
a new ARD performance metric was added to the Performance Monitoring
Infrastructure to measure the time for a complete request through
the ARD channel. The granularity of these metrics is at the request
URI level.  </p>
<p>Since ARD is an optional feature that has to be
enabled, no performance decline is seen when not utilizing ARD. However,
non-ARD applications that reside on an ARD-enabled application server
would suffer from the extra layer of the ARDChannel. The channel layer
does not know to which application it is going so it is either on
or off for all applications in a channel chain. These are defined
per virtual host.</p>

</div>

<div class="section">
<h4 class="sectiontitle">Security </h4>
<p>Security is not invoked on synchronous
include dispatches according to the servlet specification. However,
security context is passed along through AsynchBeans to support programmatic
usage of the isUserInRole and getUserPrincipal methods on the ServletRequest.
This security context can also be propagated across to a remote request
dispatch utilizing Web services security.</p>

</div>


</div>

<br clear="none" />
<br clear="none" />
<hr align="left" />
<div>
<div class="relconcepts">
<strong>Related concepts</strong>
<br clear="none" />
<div>
<div>
<a href="cweb_ard.html" shape="rect">Asynchronous request dispatcher</a>
</div>

</div>

</div>
<div class="reltasks">
<strong>Related tasks</strong>
<br clear="none" />
<div>
<div>
<a href="tweb_ard.html" shape="rect">Developing servlet applications using asynchronous request dispatcher</a>
</div>

</div>

</div>
<div class="relinfo">
<strong>Related information</strong>
<br clear="none" />
<div>
<div>
<a href="http://www.ibm.com/developerworks/websphere/techjournal/0608_hesmer/0608_hesmer.html" shape="rect" target="_blank">http://www.ibm.com/developerworks/websphere/techjournal/0608_hesmer/0608_hesmer.html</a>
</div>

</div>

</div>

</div>
<span class="runningfooter">
<img alt="Reference topic" src="../../reference_obj.gif" style="margin-top:8; border:0" /> <strong>Reference topic</strong></span>
         
   <br clear="none" />
<hr align="left" />
<a class="runningfooter" href="../../terms_of_use.html" shape="rect">
<strong>Terms of Use</strong></a> |
<a class="runningfooter" href="mailto:wasdoc@us.ibm.com" shape="rect" target="_blank">
<strong>Feedback</strong></a>
<br clear="none" />
<br clear="none" />
<img alt="Last updated" src="../../timestamp.gif" style="margin-right:4; border:0; valign:middle" />
<span class="runningfooter">Last updated: May 12, 2011 2:02:39 AM CDT </span>
<br clear="none" />
<span class="runningfooter">http://www14.software.ibm.com/webapp/wsbroker/redirect?version=compass&amp;product=was-express-dist&amp;topic=rwebardconsiderations<br clear="none" />File name: rweb_ard_considerations.html</span>
<br clear="none" />
<br clear="none" />
<div id="ibm-metrics">
<script src="//www.ibm.com/common/stats/stats.js" type="text/javascript" xml:space="preserve">//</script>
</div>
</body>

</html>