<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
	
		<title>WebLCC Runtime Environment</title>
		
		<meta http-equiv="Content-Script-Type" content="text/javascript" />
		
		<link rel="stylesheet" href="jscc.css" type="text/css" />
		<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
    <meta http-equiv="description" content="this is my page">
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="stylesheet" href="browser-lcc/jquery/jquery-ui-1.7.3.custom.css" type="text/css">
	<script type="text/javascript" src="browser-lcc/jquery/jquery-1.3.2.min.js"></script>
	<script type="text/javascript" src="browser-lcc/jquery/jquery-ui-1.7.3.custom.min.js"></script>
	<script type="text/javascript" src="browser-lcc/strophe/strophejs-1.0.1/strophe.js"></script>
	<script type="text/javascript" src="browser-lcc/strophe/flXHR/flXHR.js"></script>
	<script type="text/javascript" src="browser-lcc/strophe/strophejs-1.0.1/plugins/strophe.flxhr.js"></script>
  	<script type="text/javascript" src="browser-lcc/event.js"></script>
  	<script type="text/javascript" src="browser-lcc/okbuzzer.js"></script>
	<script type="text/javascript" src="browser-lcc/browserlcc.js"></script>
	<script type="text/javascript" src="browser-lcc/jscc/jscc.js"></script>
	<script type="text/javascript" src="browser-lcc/jscc/driver.js"></script>
	<script type="text/javascript" src="browser-lcc/jscc/webdriver.js"></script>
	<style type="text/css">
		body {
			font-family: Helvetica;
		}
		
		h1 {
			text-align: center;
		}
		
		textarea {
			font-size: 12px;
		}
		
		.button {
			padding: 5px;
			background-color: #ddd;
			border: solid 1px #666;
			font-weight: bold;
		}
		
		.hidden {
			display: none;
		}
		
		a:link, a:visited	{ border:0; text-decoration: none; color: #003168; font-weight: bold; font-size: 10px; }
		a:hover				{ border:0; text-decoration: none; color: #0683FF; font-weight: bold; }
		img					{ border:0; }
		
		html, body, td		{ font-family: Courier New, Sans-serif; font-size: 11px; }
		table.debug,
			table.print		{ width: 100%; border: 1px solid #707070 ; margin-bottom: 5px; }
		table.print td		{ text-align: center; white-space: nowrap; }
		
		hr					{ line-height: 1px; color: black; }
		#output, #js_code,
			#parsetree		{ height: 200px; border-top: 1px solid #707070 ;
								border-left: 1px solid #707070 ; padding: 10px; overflow: scroll; }
		#js_code			{ height: 300px;  }
		.elem_title			{ text-align: center; font-size: 11px; font-weight: bold; 
								 color: white; height: 15px;
									background-image: url( "img/back.png" );
										background-repeat: repeat-x; }
		
		#progname			{ font-size: 18px; font-weight: bold; margin: 0; padding: 0; text-align: center; }
		#version			{ font-size: 14px; font-weight: bold; margin: 0; padding: 0; text-align: center; }
		#copyright			{ font-size: 12px; font-weight: bold; margin: 0; padding: 0; text-align: center; }
		#visit_us			{ font-size: 12px; color: #bdbdbd; margin: 0; padding: 0; text-align: center; }		
		#copyrightinfo		{ border: 3px solid black; font-family: Verdana, Helvetica, Arial, Sans-serif; }
		
		td.node_name		{ font-family: Courier New, Helvetica, Sans-serif; font-size: 11px; padding-left: 10px; }
		td.node_name span	{ color: rgb( 2, 143, 65 ); font-weight:bold; }
		
		#popupcontent		{ position: absolute; visibility: hidden; overflow: hidden; border:1px solid #CCC; background-color:#F9F9F9; border:1px solid #333; padding:5px; overflow: scroll; }
	</style>
		<script type="text/javascript">
		function OKBuzzer () {
    this.connection = null;
}

	OKBuzzer.prototype.jid_to_id = function (jid) {
	    return Strophe.getBareJidFromJid(jid).replace(/@/g, "-").replace(/\./g, "-");
	};
	
	OKBuzzer.prototype.on_message = function (message) {
	    var full_jid = $(message).attr('from');
	    var body = $(message).find("html > body");
	    return true;
	};
	var okbuzzer = new OKBuzzer();
	
	$(document).ready(function () {
	    $('#login_dialog').dialog({
	        autoOpen: true,
	        dragOKBuzzerle: false,
	        modal: true,
	        title: 'Connect to XMPP',
	        buttons: {
	            "Connect": function () {
	                $(document).trigger('connect', {
	                	server: $("#server").val(),
	                    jid: $('#jid').val(),
	                    password: $('#password').val()
	                });
	                
	                $('#password').val('');
	                $(this).dialog('close');
	            }
	        }
	    });
	    
	    $("disconnect").click(function(){
			okbuzzer.connection.disconnect();
			okbuzzer.connection = null;
		});
	});
	    
	$(document).bind('connect', function (ev, data) {
	    var conn = new Strophe.Connection(data.server);
	
	    conn.connect(data.jid, data.password, function (status) {
	        if (status === Strophe.Status.CONNECTED) {
	            $(document).trigger('connected');
	        } else if (status === Strophe.Status.DISCONNECTED) {
	            $(document).trigger('disconnected');
	        }
	    });
		
	    okbuzzer.connection = conn;
	});
		
	$(document).bind('connected', function () {
	    okbuzzer.connection.addHandler(OKBuzzer.on_message, null, "message", "chat");
	});
		
	$(document).bind('disconnected', function () {
	    okbuzzer.connection = null;
	    $('#login_dialog').dialog('open');
	});
		</script>
		<script type="text/javascript">
		var html_output = new String();
		var error_output = new String();
		var	dfa_table;
		
		function _error( msg )
		{
			if( show_errors )
				error_output += "Error: " + msg + "\n";

			errors++;
		}
		
		function _warning( msg )
		{
			if( show_warnings )
				error_output += "Warning: " + msg + "\n";

			warnings++;
		}
		
		function _print( txt )
		{
			html_output += txt;
		}
		
		function check_editor_content()
		{
			if( document.source.code.value != "" )
				if( confirm( "Delete current editor content?" ) )
				{
					document.source.code.value = "";
					document.source.code.focus();
					document.source.run.disabled = true;
					return true;
				}
				else
					return false;

			return true;
		}
		
		function reset()
		{
			if( document.source.code.value != "" )
				if( confirm( "Delete current LCC?" ) )
				{
					document.getElementById("fromOKBook").value = "";
					document.getElementById("fromOKBook").focus();
					document.getElementById("trigger").onclick = "return";
					return true;
				}
				else{
					document.getElementById("trigger").onclick = "run_parser();";
					return false;
				}

			return true;
		}
		
		function load_grammar()
		{
			if( check_editor_content() )
			{
				document.source.code.value = grammars[ document.source.stored.value ];
				document.source.code.focus();
				
				document.source.run.disabled = true;
			}
		}
		
		function enlarge_content( container )
		{
			var closebutton = "<div style=\"width:100%; text-align: center;\"><input type=\"button\" onclick=\"hide_enlarged_content();\" width=\"100%\" value=\"Close\" /></div>";
			var pop_up = document.getElementById( "popupcontent" );
			pop_up.style.top = "100px";
			pop_up.style.left = "200px";
			pop_up.style.width = "800px";
			pop_up.style.height = "600px";
			
			pop_up.innerHTML = closebutton + "<hr />" +
				document.getElementById( container ).innerHTML +
					"<hr />" +  closebutton;

			pop_up.style.visibility = "visible";
		}
		
		function hide_enlarged_content()
		{
			var pop_up = document.getElementById("popupcontent");
			pop_up.style.visibility = "hidden";	
		}
		
		function run_parser()
		{
			var driver = new String( driver_t );
			var webdriver = new String( webdriver_t );

			if( !code_foot )
				code_foot = "var error_offsets = new Array(); var error_lookaheads = new Array(); var error_count = 0; var str = prompt( \"Please enter a string to be parsed:\", \"\" ); if( ( error_count = __parse( str, error_offsets, error_lookaheads ) ) > 0 ) { var errstr = new String(); for( var i = 0; i < error_count; i++ ) errstr += \"Parse error in line \" + ( str.substr( 0, error_offsets[i] ).match( /\\n/g ) ? str.substr( 0, error_offsets[i] ).match( /\\n/g ).length : 1 ) + \" near \\\"\" + str.substr( error_offsets[i] ) + \"\\\", expecting \\\"\" + error_lookaheads[i].join() + \"\\\"\\n\" ; alert( errstr );}";

			//driver is for output
			driver = driver.replace( /##PREFIX##/gi, "" );
			driver = driver.replace( /##HEADER##/gi, code_head );
			driver = driver.replace( /##TABLES##/gi, print_parse_tables( MODE_GEN_JS ) );
			driver = driver.replace( /##DFA##/gi, print_dfa_table( dfa_table ) );
			driver = driver.replace( /##TERMINAL_ACTIONS##/gi, print_term_actions() );
			driver = driver.replace( /##LABELS##/gi, print_symbol_labels() );
			driver = driver.replace( /##ACTIONS##/gi, print_actions() );
			driver = driver.replace( /##FOOTER##/gi, code_foot );
			driver = driver.replace( /##ERROR##/gi, get_error_symbol_id() );
			driver = driver.replace( /##EOF##/gi, get_eof_symbol_id() );
			driver = driver.replace( /##WHITESPACE##/gi, get_whitespace_symbol_id() );
			
			//webdriver is for execution and parse tree generator
			webdriver = webdriver.replace( /##PREFIX##/gi, "" );
			webdriver = webdriver.replace( /##HEADER##/gi, code_head );
			webdriver = webdriver.replace( /##TABLES##/gi, print_parse_tables( MODE_GEN_JS ) );
			webdriver = webdriver.replace( /##DFA##/gi, print_dfa_table( dfa_table ) );
			webdriver = webdriver.replace( /##TERMINAL_ACTIONS##/gi, print_term_actions() );
			webdriver = webdriver.replace( /##LABELS##/gi, print_symbol_labels() );
			webdriver = webdriver.replace( /##ACTIONS##/gi, print_actions() );
			webdriver = webdriver.replace( /##FOOTER##/gi, code_foot );
			webdriver = webdriver.replace( /##ERROR##/gi, get_error_symbol_id() );
			webdriver = webdriver.replace( /##EOF##/gi, get_eof_symbol_id() );
			webdriver = webdriver.replace( /##WHITESPACE##/gi, get_whitespace_symbol_id() );			
			//driver = webdriver;
			
			//output the code
			document.getElementById( "js_code" ).innerHTML = driver.replace( /\n/g, "<br />" ).replace( /\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;" );

			//run the webdriver
			eval( webdriver );
		}
		
		function build()
		{
			var pure_code, out_code, i;
			
			html_output = new String();
			error_output = new String();
			reset_all( EXEC_WEB );
			
			show_warnings = document.source.with_warnings.checked;

			var src = new String( document.source.code.value );
			parse_grammar( src ); //parse the .par file
			
			if( errors == 0 )
			{
				undef();
				unreachable();
				
				if( errors == 0 )
				{
					first();
					print_symbols();
					print_grammar( MODE_GEN_HTML );
					
					html_output += "<hr />";
					
					dfa_table = create_subset( nfa_states );
					dfa_table = minimize_dfa( dfa_table );

					lalr1_parse_table( true );
					
					errors = 0;
					if( errors == 0 )
						document.getElementById( "output" ).innerHTML = html_output + "<hr />" + print_parse_tables( MODE_GEN_HTML );
				}
			}

			if( errors > 0 || warnings > 0 && error_output != "" )
				alert( error_output );
			
			if( errors == 0 )
				document.source.run.disabled = false;
		}

		var grammars = new Array();
		grammars.push( "/~\n    This is a four-function calculator, where precedences\n    are defined via associativity definitions of tokens.\n\n    IMPORTANT: The Warnings coming up when invoking JS/CC\n               are coming from the grammar, and are resolved\n               in order to the precedences and associativity\n               information passed to each token.\n~/\n\n\n/~ --- Token definitions --- ~/\n\n/~ Characters to be ignored ~/\n!   \' |\\t\' ;\n\n/~ Non-associative tokens ~/\n    \'\\(\'\n    \'\\)\'\n    \'[0-9]+\'                        INT   [* %match = parseInt( %match ); *]\n    \'[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+\' FLOAT [* %match = parseFloat( %match ); *]\n    ;\n\n/~ Left-associative tokens, lowest precedence ~/\n<  \'\\+\'\n   \'\\-\';\n        \n/~ Left-associative tokens, highest precedence ~/\n<  \'\\*\'\n   \'/\';\n\n##\n\n/~ --- Grammar specification --- ~/\n\np:      e              [* alert( %1 ); *]\n        ;\n\ne:      e \'+\' e        [* %% = %1 + %3; *]\n        | e \'-\' e      [* %% = %1 - %3; *]\n        | e \'*\' e      [* %% = %1 * %3; *]\n        | e \'/\' e      [* %% = %1 / %3; *]\n        | \'-\' e &\'*\'   [* %% = %2 * -1; *]\n        | \'(\' e \')\'    [* %% = %2; *]\n        | INT\n        | FLOAT\n        ;" );
		
		grammars.push( "/~\n\tXPL - eXample Programming Language v0.3\n\tWritten 2007 by J.M.K S.F. Software Technologies, Jan Max Meyer\n\t\n\tThe complete source of this program is in the Public Domain.\n\t\n\tThis example demonstrates the implementation of XPL, a complete,\n\tinterpretered scripting language, written in JS/CC.\n\t\n\tXPL provides simple input/output operations and can only handle\n\tnumeric values.\n\t\n\tWatch out for the *.xpl-files within the example directory, which\n\tcontain example scripts to be executed using XPL, for example a\n\tcountdown or a calculator.\n~/\n\t\n\t\n[*\n\n//Structs\nfunction NODE()\n{\n\tvar type;\n\tvar value;\n\tvar children;\n}\n\n//Defines\nvar NODE_OP\t= 0;\nvar NODE_VAR\t= 1;\nvar NODE_CONST\t= 2;\n\nvar OP_NONE\t= -1;\nvar OP_ASSIGN\t= 0;\nvar OP_IF\t= 1;\nvar OP_IF_ELSE\t= 2;\nvar OP_WHILE_DO\t= 3;\nvar OP_DO_WHILE\t= 4;\nvar OP_WRITE\t= 5;\nvar OP_READ\t= 6;\nvar OP_SAY\t= 7;\n\nvar OP_EQU\t= 10;\nvar OP_NEQ\t= 11;\nvar OP_GRT\t= 12;\nvar OP_LOT\t= 13;\nvar OP_GRE\t= 14;\nvar OP_LOE\t= 15;\nvar OP_ADD\t= 16;\nvar OP_SUB\t= 17;\nvar OP_DIV\t= 18;\nvar OP_MUL\t= 19;\nvar OP_NEG\t= 20;\n\n//Management functions\nfunction createNode( type, value, childs )\n{\n\tvar n = new NODE();\n\tn.type = type;\n\tn.value = value;\t\n\tn.children = new Array();\n\t\n\tfor( var i = 2; i < arguments.length; i++ )\n\t\tn.children.push( arguments[i] );\n\t\t\n\treturn n;\n}\n\nvar v_names = new Array();\nvar v_values = new Array();\n\n//Interpreting function\nfunction letvar( vname, value )\n{\n\tvar i;\n\tfor( i = 0; i < v_names.length; i++ )\n\t\tif( v_names[i].toString() == vname.toString() )\n\t\t\tbreak;\n\t\t\n\tif( i == v_names.length )\n\t{\n\t\tv_names.push( vname );\n\t\tv_values.push( 0 );\n\t}\n\t\n\tv_values[i] = value;\n}\n\nfunction getvar( vname )\n{\n\tvar i;\n\tfor( i = 0; i < v_names.length; i++ )\n\t\tif( v_names[i].toString() == vname.toString() )\n\t\t\treturn v_values[i];\n\t\t\t\n\treturn 0;\n}\n\nfunction execute( node )\n{\n\tvar ret = 0;\n\t\n\tif( !node )\n\t\treturn 0;\n\t\t\n\tswitch( node.type )\n\t{\n\t\tcase NODE_OP:\n\t\t\tswitch( node.value )\n\t\t\t{\n\t\t\t\tcase OP_NONE:\n\t\t\t\t\tif( node.children[0] )\n\t\t\t\t\t\texecute( node.children[0] );\t\t\t\t\t\n\t\t\t\t\tif( node.children[1] )\n\t\t\t\t\t\tret = execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_ASSIGN:\n\t\t\t\t\tletvar( node.children[0], execute( node.children[1] ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_IF:\n\t\t\t\t\tif( execute( node.children[0] ) )\n\t\t\t\t\t\texecute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_IF_ELSE:\n\t\t\t\t\tif( execute( node.children[0] ) )\n\t\t\t\t\t\texecute( node.children[1] );\n\t\t\t\t\telse\n\t\t\t\t\t\texecute( node.children[2] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_WHILE_DO:\n\t\t\t\t\twhile( execute( node.children[0] ) )\n\t\t\t\t\t\texecute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_DO_WHILE:\n\t\t\t\t\tdo\n\t\t\t\t\t\texecute( node.children[0] )\n\t\t\t\t\twhile( execute( node.children[1] ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_WRITE:\n\t\t\t\t\talert( execute( node.children[0] ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_READ:\n\t\t\t\t\tletvar( node.children[0].toString(), prompt( \"Please enter a value:\", \"0\"  ) );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_SAY:\n\t\t\t\t\talert( node.children[0] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_EQU:\n\t\t\t\t\tret = execute( node.children[0] ) == execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_NEQ:\n\t\t\t\t\tret = execute( node.children[0] ) != execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_GRT:\n\t\t\t\t\tret = execute( node.children[0] ) > execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_LOT:\n\t\t\t\t\tret = execute( node.children[0] ) < execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_GRE:\n\t\t\t\t\tret = execute( node.children[0] ) >= execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_LOE:\n\t\t\t\t\tret = execute( node.children[0] ) <= execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_ADD:\n\t\t\t\t\tret = execute( node.children[0] ) + execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_SUB:\n\t\t\t\t\tret = execute( node.children[0] ) - execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_DIV:\n\t\t\t\t\tret = execute( node.children[0] ) / execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_MUL:\n\t\t\t\t\tret = execute( node.children[0] ) * execute( node.children[1] );\n\t\t\t\t\tbreak;\n\t\t\t\tcase OP_NEG:\n\t\t\t\t\tret = execute( node.children[0] ) * -1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase NODE_VAR:\n\t\t\tret = Number( getvar( node.value ) );\n\t\t\tbreak;\n\t\t\t\n\t\tcase NODE_CONST:\n\t\t\tret = Number( node.value );\n\t\t\tbreak;\n\t}\n\t\n\treturn ret;\n}\n\n*]\n\n!\t\' |\\r|\\n|\\t\'\n\n\t\"IF\"\n\t\"ELSE\"\n\t\"WHILE\"\n\t\"DO\"\n\t\"SAY\"\n\t\"WRITE\"\n\t\"READ\"\n\t\'{\'\n\t\'}\'\n\t\';\'\n\t\'=\'\n\t\'==\'\n\t\'!=\'\n\t\'<=\'\n\t\'>=\'\n\t\'>\'\n\t\'<\'\n\t\'\\+\'\n\t\'\\-\'\n\t\'/\'\n\t\'\\*\'\n\t\'\\(\'\n\t\'\\)\'\n\t\'#\'\n\t\'[A-Za-z_][A-Za-z0-9_]*\'\tIdentifier\n\t\'\\\'([^\\\']|\\\'\\\')*\\\'\'\t\tString\t\t[* %match = %match.substr( 1, %match.length - 2 );\n\t\t\t\t\t\t\t\t   %match = %match.replace( /\'\'/g, \"\\\'\" );\t*]\n\t\'[0-9]+\'\t\t\tInteger\n\t\'[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+\'\tFloat\n\t;\n\n##\n\nProgram:\tProgram Stmt\t\t\t[* execute( %2 ); *]\n\t\t|\n\t\t;\n\nStmt_List:\tStmt_List Stmt\t\t\t[* %% = createNode( NODE_OP, OP_NONE, %1, %2 ); *]\n\t\t|\n\t\t;\n\t\t\t\t\t\t\t\t\nStmt:\t\tIF Expression Stmt \t\t[* %% = createNode( NODE_OP, OP_IF, %2, %3 ); *]\n\t\t| IF Expression Stmt ELSE Stmt\t[* %% = createNode( NODE_OP, OP_IF_ELSE, %2, %3, %5 ); *]\n\t\t| WHILE Expression DO Stmt \t[* %% = createNode( NODE_OP, OP_WHILE_DO, %2, %4 ); *]\n\t\t| DO Stmt WHILE Expression \';\'\t[* %% = createNode( NODE_OP, OP_DO_WHILE, %2, %4 ); *]\n\t\t| SAY String \';\'\t\t[* %% = createNode( NODE_OP, OP_SAY, %2 ); *]\n\t\t| WRITE Expression \';\'\t\t[* %% = createNode( NODE_OP, OP_WRITE, %2 ); *]\n\t\t| READ Identifier \';\'\t\t[* %% = createNode( NODE_OP, OP_READ, %2 ); *]\n\t\t| Identifier \'=\' Expression \';\'\t[* %% = createNode( NODE_OP, OP_ASSIGN, %1, %3 ); *]\n\t\t| \'{\' Stmt_List \'}\'\t\t[* %% = %2; *]\n\t\t| \';\'\t\t\t\t[* %% = createNode( NODE_OP, OP_NONE ); *]\n\t\t;\n\t\t\t\t\nExpression:\tExpression \'==\' AddSubExp\t[* %% = createNode( NODE_OP, OP_EQU, %1, %3 ); *]\n\t\t| Expression \'<\' AddSubExp\t[* %% = createNode( NODE_OP, OP_LOT, %1, %3 ); *]\n\t\t| Expression \'>\' AddSubExp\t[* %% = createNode( NODE_OP, OP_GRT, %1, %3 ); *]\n\t\t| Expression \'<=\' AddSubExp\t[* %% = createNode( NODE_OP, OP_LOE, %1, %3 ); *]\n\t\t| Expression \'>=\' AddSubExp\t[* %% = createNode( NODE_OP, OP_GRE, %1, %3 ); *]\n\t\t| Expression \'!=\' AddSubExp\t[* %% = createNode( NODE_OP, OP_NEQ, %1, %3 ); *]\n\t\t| AddSubExp\n\t\t;\n\nAddSubExp:\tAddSubExp \'-\' MulDivExp\t\t[* %% = createNode( NODE_OP, OP_SUB, %1, %3 ); *]\n\t\t| AddSubExp \'+\' MulDivExp\t[* %% = createNode( NODE_OP, OP_ADD, %1, %3 ); *]\n\t\t| MulDivExp\n\t\t;\n\t\t\t\t\nMulDivExp:\tMulDivExp \'*\' NegExp\t\t[* %% = createNode( NODE_OP, OP_MUL, %1, %3 ); *]\n\t\t| MulDivExp \'/\' NegExp\t\t[* %% = createNode( NODE_OP, OP_DIV, %1, %3 ); *]\n\t\t| NegExp\n\t\t;\n\t\t\t\t\nNegExp:\t\t\'-\' Value\t\t\t[* %% = createNode( NODE_OP, OP_NEG, %2 ); *]\n\t\t| Value\n\t\t;\n\nValue:\t\tInteger\t\t\t\t[* %% = createNode( NODE_CONST, %1 ); *]\n\t\t| Float\t\t\t\t[* %% = createNode( NODE_CONST, %1 ); *]\n\t\t| Identifier\t\t\t[* %% = createNode( NODE_VAR, %1 ); *]\n\t\t| \'(\' Expression \')\'\t\t[* %% = %2; *]\n\t\t;\n\n[*\n\nvar str = prompt( \"Please enter an XPL-script to be executed:\",\n\t\"say \\\'Hello World\\\'; i = 0; do { write i; i = i + 1; } while i < 10;\" );\nvar error_cnt \t= 0;\nvar error_off\t= new Array();\nvar error_la\t= new Array();\n\nif( ( error_cnt = __parse( str, error_off, error_la ) ) > 0 )\n{\n\tfor( i = 0; i < error_cnt; i++ )\n\t\talert( \"Parse error near >\" \n\t\t\t+ str.substr( error_off[i], 30 ) + \"<, expecting \\\"\" + error_la[i].join() + \"\\\"\" );\n}\n*]" );

		</script>
	</head>
	<body>
		<table width="100%" border="0" cellpadding="0" cellspacing="2">
			<tr>
				<td colspan="2" id="copyrightinfo">
					<div id="progname">
						WebLCC Runtime Environment
					</div>
					<div id="version">
						<script type="text/javascript">
						<!--
							document.write( "Version 1.0 " );
						-->
						</script>
					</div>
					<div id="copyright">Copyright &copy; 2010-2011 by Xi Bai</div>
					<div id="visit_us"><a href="http://www.openk.org">OpenKnowledge</a></div>
				</td>
			</tr>
			<tr>
				<td colspan="2" class="elem_title">
					LCC Grammar Editor
				</td>
			</tr>
			<tr>
				<td colspan="2">
					<form action="" name="source">
						<table width="100%" style="margin: 0; padding: 0;" cellpadding="0" cellspacing="0">
							<tr>
								<td width="100%">
								    <select name="stored" size="1" style="width: 100%">
	     								<option value="0">Calculator</option>
	      								<option value="1">Example Programming Language</option>
	    							</select>
								</td>
								<td>
									<input type="button" value="Load" onclick="load_grammar()" />									
								</td>
								<!--
								<td>
									<input type="button" value="Save" />
								</td>
								-->
								<td>
									<input type="button" value="Clear" onclick="check_editor_content()" />
								</td>
							</tr>
						</table>
						
						<textarea id="code" name="code" rows="10" cols="255" style="width: 100%;" onchange="document.source.run.disabled = true;">
	/~ Lightweight Coordination Calculus (LCC) Interpreter ~/

[*

	var constraints = {};
	var emitter = new EventEmitter;
	emitter.removeAllListeners("okcs loaded");
	emitter.on("okcs loaded", execute);
	emitter.removeAllListeners("msgReceived");
	emitter.on("msgReceived", receiveMSG);
//	emitter.removeAllListeners("sendMSG");
//	emitter.on("sendMSG", execute);
	function OKBuzzer () {
    this.connection = null;
}

	OKBuzzer.prototype.jid_to_id = function (jid) {
	    return Strophe.getBareJidFromJid(jid).replace(/@/g, "-").replace(/\./g, "-");
	};
	
	OKBuzzer.prototype.on_message = function (message) {
	    var full_jid = $(message).attr('from');
	    var body = $(message).find("html > body");
	    return true;
	};
	var okbuzzer = new OKBuzzer();
	
	$(document).ready(function () {
	    $('#login_dialog').dialog({
	        autoOpen: true,
	        dragOKBuzzerle: false,
	        modal: true,
	        title: 'Connect to XMPP',
	        buttons: {
	            "Connect": function () {
	                $(document).trigger('connect', {
	                	server: $("#server").val(),
	                    jid: $('#jid').val(),
	                    password: $('#password').val()
	                });
	                
	                $('#password').val('');
	                $(this).dialog('close');
	            }
	        }
	    });
	    
	    $("disconnect").click(function(){
			okbuzzer.connection.disconnect();
			okbuzzer.connection = null;
		});
	});
	    
	$(document).bind('connect', function (ev, data) {
	    var conn = new Strophe.Connection(data.server);
	
	    conn.connect(data.jid, data.password, function (status) {
	        if (status === Strophe.Status.CONNECTED) {
	            $(document).trigger('connected');
	        } else if (status === Strophe.Status.DISCONNECTED) {
	            $(document).trigger('disconnected');
	        }
	    });
		
	    okbuzzer.connection = conn;
	});
		
	$(document).bind('connected', function () {
	    okbuzzer.connection.addHandler(OKBuzzer.on_message, null, "message", "chat");
	});
		
	$(document).bind('disconnected', function () {
	    okbuzzer.connection = null;
	    $('#login_dialog').dialog('open');
	});
	
	var v_names = new Array();
	var v_values = new Array();
	var okcs = new Array();
	var init;
	
	var NODE_OP			= 1;
	var NODE_VAR 		= 2;
	var NODE_CONST		= 3;
	
	
	var OP_NONE 		= -1;
	var OP_INIT			= 5;
	var OP_SEND 		= 0;
	var OP_RECEIVE		= 1;
	var OP_THEN			= 2;
	var OP_OR			= 3;
	var OP_LIST 		= 4;
	var OP_ROLE_DEF		= 6;
	var OP_SEND 		= 7;
	var OP_RECEIVE		= 8;
	var OP_ROLE_TYPE    = 9;
	var OP_SET_VAR      = 10;
	var OP_CONSTRAINT	= 11;
	var OP_NEGATE		= 12;
	var OP_LOGAND		= 13;
	var OP_LOGOR		= 14;
	var OP_NO_MSG		= 15;
	var OP_TERMS		= 16;
	var OP_FACTOR		= 17;
	var OP_MESSAGE		= 18;
//	var state = {
//		currentDef : []	
//	};
	
	function Node(){
		var type;
		var value;
		var children;
	} 
	
	function FACTOR(){
		var name;
		var params;
	}
		
	function createNode(type, value, childs){
		var n = new Node();
		n.type = type;
		n.value = value;
		n.child = new Array();
		
		for(var i = 2; i < arguments.length; i++){
			n.child.push(arguments[i]);
		}
		return n;
	}
	
	function createFactors(name, params){
		var f = new FACTOR();
		f.name = name;
		f.params = params;
		return f;
	}	
	
	function setValue(vname, vvalue){
		var found = false;
		for(var i = 0; i < v_names.length; i++){
			if(v_names[i].toString() == vname.toString()){
				v_values[i] = (arguments.length == 1)? undefined : vvalue; //The type is now checked here.
				found = true;
				break;
			}
			
		}
		if(!found){
			v_names.push(vname);
			v_values.push((arguments.length == 1)? undefined : vvalue);
		}
	}
	
	function getValue(vname){
		for(var i = 0; i < v_names.length; i++){
			if(v_names[i].toString() == vname.toString()){
				return v_values[i];
			}
		}
		return undefined;
	}
	
	function retrieveOKCs(okcs, headElem, count, length, node){
		var okcElem = document.createElement("script");
		okcElem.type = "text/javascript";
		okcElem.src =  okcs[count++];
		okcElem.onload = loadCounting(okcs.length, count, node);
		headElem.appendChild("okcElem");
		if(count == length){
			emitter.emit("okcs loaded", node);
		}
		else{
			retrieveOKCs(okcs, headElem, count, length, node);
		}
	}
	
	function initialize(jsonStr, node){
		init = eval('(' + jsonStr + ')');
		for(var i = 0; i < init.length; i++){
			for(var j = 0; j < init[i].okcs.length; j++){
				okcs.push(init[i].okcs[j]);
			}
		}
		var count = 0;
		var length = okcs.length;
		var headElem = document.getElementsByTagName("head")[0];
		retrieveOKCs(okcs, headElem, count, length, node);
	}
	
	function sendMSG(msgJSONStr, receiverJID){
		var success;
		//TODO XMPP sending message.
		
		//when receive message
		emitter.emit("receive");
		return success;
	}
	
	function receiveMSG(msgJSONStr, roleNode, constraintNode){
		//TODO XMPP receiving message.
		if(arguments[2]){
			if(arguments[2] == true){
				if(emitter.listeners("nextThenDEF") || emitter.listeners("nextThenDEF").length == 0){
					emitter.emit("nextThenDEF");
				}
			}
			else{
				if(emitter.listeners("nextOrDEF") || emitter.listeners("nextOrDEF").length == 0){
					emitter.emit("nextOrDEF")
				}
			}
		}
		else{
			if(emitter.listeners("nextThenDEF") || emitter.listeners("nextThenDEF").length == 0){
				emitter.emit("nextThenDEF");
			}
			else if(emitter.listeners("nextOrDEF") || emitter.listeners("nextOrDEF").length == 0){
				emitter.emit("nextOrDEF");
			}
		}
	}
	
	function execute(node){
		var ret = 0;
		if(!node)
			return 0;
		switch(node.type){
			case NODE_OP: 
				switch(node.value){
					case OP_NONE:
						if(node.children[0]){
							execute(node.children[0]);
						}
						if(node.children[1]){
							ret = execute(node.children[1]);
						}
						break;
					case OP_ROLE:
						var roleIdNode = node.children[1];
						var roleType = eval("(" + execute(node.children[0]) + ")");
						var reoleName = roleType.name;
						for(var i = 0; i < init.length; i++){
							if(roleName.toString().toLowerCase == init[i].role.toString().toLowerCase){
								ret = init[i].jid.toString();
							}
						}
						break;
					case OP_ROLE_TYPE:
						var ret = execute(node.children[0]);
						break;
					case OP_TERMS:
						if(node.children[1]){
							ret = execute(node.children[0]) + ", " + execute(node.children[1]);
						}
						else{
							ret = execute(node.children[0]);
						}
						break;
					case OP_FACTOR:
						if(node.children[1])
							ret = "{ name : '" + execute(node.children[0]) + "', params: [" + execute(node.children[1]) + "]}";
						else
							ret = "{ name : '" + execute(node.children[0]) + "', params:[]}";
						break;
					case OP_CONSTRAINT://TODO need check the Variables and which of them are inputs and wich of them are outputs (callback?).
						var constraintName = execute(node.children[0]);
						ret = eval("okc" + funcName + "(" + "[" + execute(node.children[1]) + "]" + ")"); //according to "Conventions over configurations"
						if(ret == null || ret == undefined)
							throw invalidOKCException(funcName);
						break;
					case OP_NEGATE:
						ret = !execute(node.children[0]);	
						break;
					case LOGAND:
						ret = execute(node.children[0]) && execute(node.children[1]);
						break;
					case LOGOR:
						ret = execute(node.children[0]) || execute(node.children[1]);
						break;
					case OP_LIST:
						if(execute(node.children[0]) != undefined){
							if(execute(node.children[0]).length == 0){
								setValue(node.children[1].value.toString(), []);
								setValue(node.children[2].value.toString(), []);
							}
							else if(execute(node.children[0]).length = 1){
								setValue(node.children[1].value.toString(), execute(node.children[0])[0]);
								setValue(node.children[2].value.toString(), []);
							}
							else if(execute(node.children[0]).length > 1){
								setValue(node.children[1].value.toString(), execute(node.children[0])[0]);
								setValue(node.children[2].value.toString(), execute(node.children[0]).slice(1));
							}
						}
						else if(execute(node.children[1]) != undefined && execute(node.children[2]) != undefined){
							setValue(node.children[0].value.toString(), execute(node.children[1]).concat(execute(node.children[2])));
						}
						if(execute(node.children[1]) != undefined && execute(node.children[2]) != undefined){
							setValue(node.children[0].value.toString(), []);
						}
						break;
					case OP_THEN:
						emitter.removeAllListeners("nextThenDEF");
						emitter.on("nextThenDEF", execute(node.children[1]));
						execute(node.children[0]);
						break;
					case OP_OR:
						emitter.removeAllListeners("nextOrDEF");
						emitter.on("nextOrDEF", execute(node.children[1]));
						execute(node.children[0]);
						break;
					case OP_SEND:
						var msgNode = node.children[0];
						var roleNode = node.children[1];
						var solved = true;
						if(node.children[2]){
							solved = execute(node.children[2]);
						}
						if(solved){
							if(sendMSG(execute(msgNode), execute(roleNode))){
								if(emitter.listeners("nextThenDEF") || emitter.listeners("nextThenDEF").length == 0)
									emitter.emit("nextThenDEF");
							}
							else{
								if(emitter.listeners("nextOrDEF") || emitter.listeners("nextOrDEF").length == 0)
									emitter.emit("nextOrDEF");
							}
						}
						break;
					case OP_RECEIVE: 
						emitter.removeAllListers("receive");
						var msgNode = node.children[0];
						var roleNode = node.children[1];
						if(node.children[2]){
							emitter.on("msgReceived", receiveMSG(execute(msgNode), execute(roleNode), execute(node.children[2])));
						}
						else{
							emitter.on("msgReceived", receiveMSG(execute(msgNode), execute(roleNode)));
						}
						break;
					case OP_MESSAGE:
						ret = "{ name: '" + execute(node.children[0]) + "', params: [" + execute(node.children[1]) + "]}";
						break;
					case OP_NO_MSG:
						ret = execute(node.children[0]);
						break;
				}
				break;
			case NODE_VAR:
				ret = getValue(node.value);
				break;
			case NODE_CONST:
				ret = node.value;
				break;
		}
		return ret;
	}
	
	function invalidOKCException(okcName){
		return "OKC" + "'" + okcName + "()' has not been loaded."; 
	}

	
*]

/~ Lightweight Coordination Calculus (LCC) Interpreter ~/

/~ Tokens to be ignored ~/
!	'\r|\n|\t|//[^\n]*\n '
        ;								/~ This does not work. ~/

/~ Grammar tokens ~/
	"HEADER"
	"A"
/~	"KNOWS" ~/
	"NULL"
/~	"MSG" ~/
/~	"TEXT" ~/
/~	"INPUT" ~/
/~	"INITIAL" ~/
	'::'
	','
	'\.'
	'\('
	'\)'
	'\['
	'\]'
	'=>'
	'<='
	'->'
	'<-'
	'='
	'\|'                             ListBar
	"NOT"									/~ logical "NOT" ~/
	'_|([A-Z][A-Za-z0-9_]*)|([0-9]+)'	Variable
	'([a-z][A-Za-z0-9_]*)|([0-9]+)'		Constant
	'\[(.)+\]'					        JSON
	;
	
	
/~ associativity ~/
<	"OR"							
	;

<	"THEN"
	;

<	"\|\|"									/~ logical "OR" ~/
	;
	
<	"&&"									/~ logical "AND" ~/
	;	
##

IM:		"HEADER" '(' JSON ')' '.' Clause_List					/~[* initialize(%3, %6); *]~/
		;

Clause_List:	Clause
                |Clause_List Clause						
	        ;

Clause:	Role '::' Def '.'												
		;	

Role:	A '(' Type ',' Id ')'                           /~[* %% = createNode(NODE_OP, OP_ROLE, %3, %5); *]~/
		;

Type:	Term                                                /~ [* %% = createNode(NODE_OP, OP_ROLE_TYPE, %1); *] ~/
		;
	
Def:	        /~ Role changing needs to be done~/
		| Interaction
		| Def THEN Def                                            /~[* %% = createNode(NODE_OP, OP_THEN, %1, %3); *]~/
		| Def OR Def                                              /~[* %% = createNode(NODE_OP, OP_OR, %1, %3); *]~/
		;

Interaction:	Message '=>' Role                                 /~[* %% = createNode(NODE_OP, OP_SEND, %1, %3); *]~/
				| Message '=>' Role '<-' Constraint               /~[* %% = createNode(NODE_OP, OP_SEND, %1, %3, %5); *]~/
				| Message '<=' Role                               /~[* %% = createNode(NODE_OP, OP_RECEIVE, %1, %3); *]~/
				| Constraint '<-' Message '<=' Role               /~[* %% = createNode(NODE_OP, OP_RECEIVE, %3, %5, %1); *]~/
				| NULL '<-' Constraint                            /~[* %% = createNode(NODE_OP, OP_NO_MSG, %3); *]~/   /~ not in the original BNF declaration on the openk website ~/
				;

Constraint:	Constant
			| Constant '(' Terms ')'                            /~ [* %% = createNode(NODE_OP, OP_CONSTRAINT, %1, %3); *] ~/
			| NOT '(' Constraint ')'                            /~ [* %% = createNode(NODE_OP, OP_NEGATE, %3); *] ~/
			| Constraint '&&' Constraint                        /~ [* %% = createNode(NODE_OP, OP_LOGAND, %1, %3); *] ~/
			| Constraint '\|\|' Constraint                      /~ [* %% = createNode(NODE_OP, OP_LOGOR, %1, %3); *] ~/
			| Variable '=' '\[' Variable ListBar Variable '\]'	/~ [* %% = createNode(NODE_OP, OP_LIST, %1, %4, %6); *] ~/
			;
	
Terms:	Terms ',' Term                                          /~ [* %% = createNode(NODE_OP, OP_TERMS, %1, %3); *] ~/
		| Term                                                  /~ [* %% = createNode(NODE_OP, OP_TERMS, %1); *] ~/
		;
		
Term:	Constant                                                /~ [* %% = createNode(NODE_OP, OP_FACTOR, %1); *] ~/
		| Variable                                              /~ [* %% = createNode(NODE_OP, OP_FACTOR, %1); *] ~/
		| Constant '(' Terms ')'                                /~ [* %% = createNode(NODE_OP, OP_FACTOR, %1, %3)*] ~/
		;

Id:	Constant                                                    /~ [* %% = createNode(NODE_CONST, %1) *] ~/
	| Variable                                                  /~ [* %% = createNode(NODE_VAR, %1) *] ~/ 
	;

Message:	Constant '(' Terms ')'                              /~ [* %% = createNode(NODE_OP, OP_MESSAGE, %1, %3); *] ~/
			;
	
[*
	var str = document.getElementById("fromOKBook").value;
	var error_cnt 	= 0;
	var error_off	= new Array();
	var error_la	= new Array();
	
	if( ( error_cnt = __parse( str, error_off, error_la ) ) > 0 )
	{
		for( i = 0; i < error_cnt; i++ )
			alert( "Parse error near >" 
				+ str.substr( error_off[i], 30 ) + "<, expecting \"" + error_la[i].join() + "\"" );
	}
*]					
						</textarea>
						<table width="100%">
						<tr>
							<td width="50%">
								<input type="button" value="Build" style="width:100%" onclick="build()" />
							</td>
						</tr>
						</table>

						<input name="with_warnings" type="checkbox" />Show warnings
					</form>
				</td>
			</tr>
			<tr>
				<td class="elem_title">
					Grammar/State Overview &amp; Parse Tables <a href="javascript:enlarge_content( 'output' );"><img src="img/zoom.gif" /></a>
				</td>
				<td class="elem_title">
					Parse Tree <a href="javascript:enlarge_content( 'parsetree' );"><img src="img/zoom.gif" /></a>
				</td>
			</tr>
			<tr>
				<td width="50%">
					<div id="output">
						<!-- Element to output debugging information -->
						Please load or enter a grammar!
					</div>
				</td>
				<td width="50%">
					<div id="parsetree">
						<!-- Element to output generated tables -->
						Run your parser to construct the parse tree!
					</div>
				</td>
			</tr>
			<tr>
				<td colspan="2" class="elem_title">
					Parser Source Code <a href="javascript:enlarge_content( 'js_code' );"><img src="img/zoom.gif" /></a>
				</td>					
			</tr>
			<tr>
				<td colspan="2">
					<div id="js_code">
					Run your parser to obtain the source code!
					</div>
				</td>
			</tr>
			<tr>
				<td colspan="2" class="elem_title">
					Parser LCC Source Code
				</td>					
			</tr>
			<tr>
				<td colspan="2">
					<textarea id="fromOKBook" name="code" rows="10" cols="255" style="width: 100%;" onchange="document.getElementById('trigger').onclick = 'run_parser();'">
header(
	[
		{
			jid : "alice@okbook.inf.ed.ac.uk",
			role : "client",
			roleType : "initial",
			okcs : ["http://alice@okbook.inf.ed.ac.uk:8818/im/okc.js"],
		}
		,
		{
			jid : "bob@okbook.inf.ed.ac.uk",
			role : "shop",
			reoleType : "";
			okcs : ["http://bob@okbook.inf.ed.ac.uk:8818/im/okc.js"],
		}
	]
).

a(client(PC), C)::
	buy(PC, CC) => a(shop, S) <- payby(CC) && lookup(S) then
	receipt <= a(shop, S).
	
a(shop, S)::
	buy(PC, CC) <= a(client(_), C) then
	receipt => a(client(_), C) <- enough_credit(CC, PC) && complete_order(PC, CC, R).					
					</textarea>
					</div>
				</td>
			</tr>
			<tr/>
			<tr/>
			<tr>
				<td width="30%">
					<span class="button" id="reset" onclick="reset();">Reset</span> &nbsp;
					<span class="button" id="trigger" onclick="run_parser();">Trigger</span> &nbsp;
					<span class="button" id="disconnect">Disconnect</span>
				</td>
			</tr>				
		</table>
		<div id="popupcontent"></div>
		<div id="login_dialog" class="hidden">
	   		<label>Server:</label><input type="text" id="server" value="http://bosh.metajack.im:5280/xmpp-httpbind"/>
	   		<label>Jid:</label><input type="text" id="jid"/>
	   		<label>Password:</label><input type="password" id="password"/>
	   	</div>
	</body>
</html>
